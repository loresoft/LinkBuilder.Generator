using RouteLink.Generators.Models;
using RouteLink.Generators.Parsing;

namespace RouteLink.Generators;

public static class RouteLinkWriter
{
    public static string GenerateLink(RouteOptions options, LinkContext linkContext)
    {
        if (linkContext is null)
            throw new ArgumentNullException(nameof(linkContext));

        var codeBuilder = new IndentedStringBuilder();
        codeBuilder
            .AppendLine("// <auto-generated />")
            .AppendLine("#nullable enable")
            .AppendLine();

        codeBuilder
            .Append("namespace ")
            .AppendLine(options.RoutesNamespace)
            .AppendLine("{")
            .IncrementIndent();

        codeBuilder
            .Append("public static partial class ")
            .Append(options.RoutesClassName)
            .AppendLine()
            .AppendLine("{")
            .IncrementIndent();

        var classNamespaces = CreateNamespaces(options, linkContext);

        // open nested types
        foreach (var containingClass in classNamespaces)
        {
            codeBuilder
                .Append("public static partial class ")
                .AppendLine(containingClass)
                .AppendLine("{")
                .IncrementIndent();
        }

        // write route link
        foreach (var route in linkContext.Routes)
            GenerateRoute(codeBuilder, route);

        // close nested types
        foreach (var containingClass in classNamespaces)
        {
            codeBuilder
                .DecrementIndent()
                .AppendLine("}");
        }

        codeBuilder
            .DecrementIndent()
            .AppendLine("}"); // class

        codeBuilder
            .DecrementIndent()
            .AppendLine("}"); // namespace

        return codeBuilder.ToString();
    }


    private static void GenerateRoute(IndentedStringBuilder codeBuilder, LinkTemplate linkTemplate)
    {

        codeBuilder
            .AppendGeneratedAttribute()
            .Append("public static string ")
            .Append(linkTemplate.Name)
            .Append("(");

        var template = linkTemplate.Template;

        bool wroteParameter = false;
        foreach (var segment in template.Segments)
        {
            if (!segment.IsParameter)
                continue;

            var type = ResolveType(segment);
            codeBuilder
                .AppendIf(", ", wroteParameter)
                .Append(type)
                .Append(' ')
                .Append(segment.Name);

            wroteParameter = true;
        }

        codeBuilder
            .AppendLine(")")
            .AppendLine("{")
            .IncrementIndent();

        if (wroteParameter)
        {
            codeBuilder
                .Append("string?[] segments = [");

            bool wroteSegment = false;
            foreach (var segment in template.Segments)
            {
                if (wroteSegment)
                    codeBuilder.Append(", ");

                if (segment.IsLiteral)
                {
                    codeBuilder
                        .Append('"')
                        .Append(segment.Text)
                        .Append('"');
                }
                else
                {
                    var type = ResolveType(segment);
                    var notString = type != "string";

                    codeBuilder
                        .Append(segment.Name)
                        .AppendIf("?", segment.IsOptional && notString)
                        .AppendIf(".ToString()", notString);
                }

                wroteSegment = true;
            }

            codeBuilder
                .AppendLine("];")
                .AppendLine();

            codeBuilder
                .AppendLine("var length = 0;")
                .AppendLine("for (int i = 0; i < segments.Length; i++)")
                .AppendLine("{")
                .IncrementIndent()
                .AppendLine("var segment = segments[i];")
                .AppendLine("length += segment != null ? segment.Length + 1 : 0;")
                .DecrementIndent()
                .AppendLine("}")
                .AppendLine();

            codeBuilder
                .AppendLine("return string.Create(length, segments, CreateLink);");
        }
        else
        {
            // no parameters, return segments as string
            codeBuilder
                .Append("return \"");

            foreach (var segment in template.Segments)
            {
                codeBuilder
                    .Append('/')
                    .Append(segment.Text);
            }

            codeBuilder
                .AppendLine("\";");

        }

        if (wroteParameter)
            codeBuilder.AppendFunctions();

        codeBuilder
            .DecrementIndent()
            .AppendLine("}");

    }


    private static IndentedStringBuilder AppendFunctions(this IndentedStringBuilder codeBuilder)
    {
        codeBuilder
            .AppendLine()
            .AppendLine("static void CreateLink(global::System.Span<char> buffer, string?[] parts)")
            .AppendLine("{")
            .IncrementIndent()
            .AppendLine("var position = 0;")
            .AppendLine("for (int i = 0; i < parts.Length; i++)")
            .AppendLine("{")
            .IncrementIndent()
            .AppendLine("if (parts[i] == null)")
            .IncrementIndent()
            .AppendLine("continue;")
            .DecrementIndent()
            .AppendLine()
            .AppendLine("buffer[position++] = '/';")
            .AppendLine()
            .AppendLine("var span = global::System.MemoryExtensions.AsSpan(parts[i]);")
            .AppendLine("span.CopyTo(buffer[position..]);")
            .AppendLine()
            .AppendLine("position += span.Length;")
            .DecrementIndent()
            .AppendLine("}")
            .DecrementIndent()
            .AppendLine("}");

        return codeBuilder;
    }

    private static IndentedStringBuilder AppendGeneratedAttribute(this IndentedStringBuilder codeBuilder)
    {
        codeBuilder
            .Append("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"")
            .Append(ThisAssembly.Product)
            .Append("\", \"")
            .Append(ThisAssembly.InformationalVersion)
            .AppendLine("\")]");

        return codeBuilder;
    }


    private static string ResolveType(TemplatePart part)
    {
        if (part.Constraints.Count == 0)
            return "string";

        var firstConstraint = part.Constraints[0];
        return ResolveType(firstConstraint);
    }

    private static string ResolveType(string? constraint)
    {
        if (constraint == null)
            return "string";


        if (string.Equals(constraint, "int", StringComparison.OrdinalIgnoreCase))
            return "int";

        if (string.Equals(constraint, "guid", StringComparison.OrdinalIgnoreCase))
            return "System.Guid";

        if (string.Equals(constraint, "long", StringComparison.OrdinalIgnoreCase))
            return "long";


        if (string.Equals(constraint, "alpha", StringComparison.OrdinalIgnoreCase))
            return "string";


        if (string.Equals(constraint, "bool", StringComparison.OrdinalIgnoreCase))
            return "bool";

        if (string.Equals(constraint, "datetime", StringComparison.OrdinalIgnoreCase))
            return "System.DateTime";


        if (string.Equals(constraint, "decimal", StringComparison.OrdinalIgnoreCase))
            return "decimal";

        if (string.Equals(constraint, "double", StringComparison.OrdinalIgnoreCase))
            return "double";

        if (string.Equals(constraint, "float", StringComparison.OrdinalIgnoreCase))
            return "float";


        if (constraint.StartsWith("max", StringComparison.OrdinalIgnoreCase))
            return "int";

        if (constraint.StartsWith("min", StringComparison.OrdinalIgnoreCase))
            return "int";

        if (constraint.StartsWith("range", StringComparison.OrdinalIgnoreCase))
            return "int";

        return "string";
    }


    private static List<string> CreateNamespaces(RouteOptions options, LinkContext linkContext)
    {
        var routeNamespances = string.IsNullOrEmpty(options.RoutesNamespace)
            ? [] : options.RoutesNamespace.Split('.');

        var classNamespaces = new List<string>();

        for (var i = 0; i < linkContext.Types.Count; i++)
        {
            if (i < routeNamespances.Length && routeNamespances[i] == linkContext.Types[i])
                continue;

            classNamespaces.Add(linkContext.Types[i]);
        }

        return classNamespaces;
    }
}
